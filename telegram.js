require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const { getEventos } = require('./commands/Events.js');
const { GetPastEvents } = require('./commands/PastEvents.js')
const { Info }  = require('./commands/TeamInfo.js')
const { getUltimoPostTwitter } = require('./commands/twitter.js');
const { UltimosResultados } = require('./commands/ultimosResultados.js');
const { gerarGrafico } = require('./commands/RankingDevelopment.js')
const { playersList, getPlayerStats } = require('./commands/nextmatch.js');  // Importe o m√≥dulo com as fun√ß√µes Info e getPlayerStats
const fs = require('fs');
const {HLTV} = require('hltv');
const { interpretarMensagemUsuario } = require('./IA/InterpretadorIA.js');
const { ProximosJogos } = require('./commands/jogos.js')


const bot = new TelegramBot(process.env.TELEGRAM_TOKEN, {
    polling: {
      interval: 1000,  
      timeout: 10,     
      consecutive_errors_threshold: 5 
    }
});

bot.setMyCommands([
  { command: '/ranking', description: 'üìä Ver ranking da HLTV' },
  { command: '/eventos', description: 'üìÖ Ver eventos futuros' },
  { command: '/ultimos_eventos', description: 'üìÅ √öltimos eventos disputados' },
  { command: '/twitter', description: 'üì∞ √öltimo post do Twitter' },
  { command: '/info', description: 'üîç Info mais recente do roster' },
  { command: '/ultimos_resultados', description: 'üéØ √öltimos resultados em torneios' },
  { command: '/grafico_rank', description: 'üìà Gr√°fico de evolu√ß√£o do time' },
  { command: '/player_stats', description: 'üìà Estat√≠sticas dos jogadores'},
  { command: '/proximojogos', description: 'üéÆ Busca os pr√≥ximos jogos'},

]);

  

console.log("Bot iniciado...");


bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;

  bot.sendMessage(chatId, `üê∫üî• Bem-vindo ao Bot da FURIA! üî•üê∫

Eu sou seu assistente inteligente da FURIA!
Aqui voc√™ encontra not√≠cias, resultados, eventos, estat√≠sticas e muito mais!
Pode falar comigo de forma tranquila ‚Äî entendo o que voc√™ escrever.  

Escolha uma op√ß√£o abaixo para come√ßarmos: üëá`, {
    reply_markup: {
      inline_keyboard: [
        [{ text: 'üìä Ranking', callback_data: 'inline_ranking' }],
        [{ text: 'üìÖ Eventos', callback_data: 'inline_eventos' }],
        [{ text: 'üìÅ √öltimos eventos', callback_data: 'inline_ultimos_eventos' }],
        [{ text: 'üì∞ √öltimo post', callback_data: 'inline_ultimo_post' }],
        [{ text: 'üìà Evolu√ß√£o no ranking', callback_data: 'inline_grafico_rank' }],
        [{ text: 'üéØ √öltimos resultados', callback_data: 'inline_ultimos_resultados' }],
        [{ text: 'üîç Info do time', callback_data: 'inline_info' }],
        [{ text: '‚öΩ Estat√≠sticas dos Jogadores', callback_data: 'inline_player_stats' }],
        [{ text: 'üéÆ Pr√≥ximos jogos', callback_data: 'inline_proximos_jogos' }]
      ]
    }
  });
});



bot.onText(/\/player_stats/, async (msg) => {
  const chatId = msg.chat.id;

  try {
      // Buscando a lista de jogadores da FURIA (ID 8297)
      const players = await playersList();  // Obt√©m a lista de jogadores (nome e id)

      // Cria os bot√µes inline para os jogadores
      const playerButtons = players.map(player => {
          return {
              text: player.name,  // Nome do jogador
              callback_data: `player_${player.id}`  // ID do jogador
          };
      });

      // Estrutura do teclado inline
      const keyboard = {
          reply_markup: {
              inline_keyboard: [playerButtons]  // Adiciona os bot√µes ao teclado
          }
      };

      // Envia a mensagem para o usu√°rio com os bot√µes para selecionar o jogador
      bot.sendMessage(chatId, "Escolha um jogador para ver as estat√≠sticas:", keyboard);
  } catch (err) {
      console.error(err);
      bot.sendMessage(chatId, "Erro ao buscar jogadores.");
  }
});

bot.on('callback_query', async (query) => {
  const chatId = query.message.chat.id;
  const callbackData = query.data;

  if (callbackData.startsWith('player_')) {
    const playerId = callbackData.split('_')[1];

    try {
      const statsMessage = await getPlayerStats(playerId);
      await bot.sendMessage(chatId, statsMessage);
    } catch (err) {
      console.error(err);
      await bot.sendMessage(chatId, "Erro ao buscar estat√≠sticas.");
    }
  } 
  
  else if (callbackData === 'inline_ranking') {
    bot.sendMessage(chatId, '/ranking (Em breve atualizado com bot√£o üòé)');
  } else if (callbackData === 'inline_eventos') {
    const evento = await getEventos();
    bot.sendMessage(chatId, evento);
  } else if (callbackData === 'inline_ultimos_eventos') {
    const ultimos = await GetPastEvents();
    bot.sendMessage(chatId, ultimos || 'Nenhum evento passado encontrado!');
  } else if (callbackData === 'inline_ultimo_post') {
    const post = await getUltimoPostTwitter();
    bot.sendMessage(chatId, post);
  }else if (callbackData === 'inline_proximos_jogos') {
    const jogos = await ProximosJogos(); 
    bot.sendMessage(chatId, jogos);
  }else if (callbackData === 'inline_grafico_rank') {
    await gerarGrafico();
    await bot.sendPhoto(chatId, fs.createReadStream('grafico-furia.png'));
    fs.unlink('grafico-furia.png', () => {});
  } else if (callbackData === 'inline_ultimos_resultados') {
    const res = await UltimosResultados();
    bot.sendMessage(chatId, res || 'Nenhum resultado dispon√≠vel!');
  } else if (callbackData === 'inline_info') {
    const info = await Info(1);
    bot.sendMessage(chatId, info);
  } else if (callbackData === 'inline_player_stats') {
    try {
      const players = await playersList();
      const playerButtons = players.map(player => [{
        text: player.name,
        callback_data: `player_${player.id}`
      }]);

      await bot.sendMessage(chatId, "Escolha um jogador para ver as estat√≠sticas:", {
        reply_markup: {
          inline_keyboard: playerButtons
        }
      });
    } catch (err) {
      console.error(err);
      await bot.sendMessage(chatId, "Erro ao buscar jogadores.");
    }
  }
});

bot.onText(/\/eventos/, async (msg) => {
  const chatId = msg.chat.id;
  const evento = await getEventos();

  bot.sendMessage(chatId, evento);
});

bot.onText(/\/proximosjogos/, async (msg) => {
  const chatId = msg.chat.id
  const resposta = await ProximosJogos();
  bot.sendMessage(chatId, resposta);
})

//OK
bot.onText(/\/ultimos_eventos/, async (msg) => {
    const chatId = msg.chat.id;
    const ultimos = await GetPastEvents();



    if (!ultimos || ultimos.trim() === '') {
        bot.sendMessage(chatId, 'Desculpe, n√£o h√° eventos passados para exibir no momento.');
    } else {
        bot.sendMessage(chatId, ultimos);
    }
});

//OK
bot.onText(/\/info/, async (msg) => {
    const chatId = msg.chat.id;
    const info = await Info(1);
    bot.sendMessage(chatId, info)
})

//OK
bot.onText(/\/ultimos_resultados/, async (msg) => {
  const chatId = msg.chat.id;
  const infos = await UltimosResultados();

  if (!infos || infos.trim() === '') {
    bot.sendMessage(chatId, "‚ùå Nenhum resultado encontrado no momento.");
  } else {
    bot.sendMessage(chatId, infos);
  }
});

//OK
bot.onText(/\/grafico_rank/, async (msg) => {
  const chatId = msg.chat.id;
  const path = 'grafico-furia.png';

  try {
    await gerarGrafico(); 

    await bot.sendPhoto(chatId, fs.createReadStream(path));

    fs.unlink(path, (err) => {
      if (err) {
        console.error('Erro ao deletar o gr√°fico:', err);
      } else {
        console.log('üßπ Gr√°fico deletado ap√≥s envio!');
      }
    });
  } catch (err) {
    console.error('Erro ao gerar ou enviar o gr√°fico:', err);
    bot.sendMessage(chatId, '‚ùå Ocorreu um erro ao gerar o gr√°fico.');
  }
});



bot.onText(/\/twitter/, async (msg) => {
    const chatId = msg.chat.id;
    const twitte = await getUltimoPostTwitter();
    bot.sendMessage(chatId, twitte)
});

bot.on('message', async (msg) => {
  const chatId = msg.chat.id;
  const text = msg.text;

  if (!text || text.startsWith('/')) return;

  switch (text) {
    case 'üìä Ranking':
      bot.sendMessage(chatId, '/ranking (Em breve atualizado com bot√£o üòé)');
      break;

    case 'üìÖ Eventos':
      const evento = await getEventos();
      bot.sendMessage(chatId, evento);
      break;

    case 'üìÅ √öltimos eventos':
      const ultimos = await GetPastEvents();
      bot.sendMessage(chatId, ultimos || 'Nenhum evento passado encontrado!');
      break;

    case 'üì∞ √öltimo post':
      const post = await getUltimoPostTwitter();
      bot.sendMessage(chatId, post);
      break;

    case 'üìà Evolu√ß√£o no ranking':
      await gerarGrafico();
      await bot.sendPhoto(chatId, fs.createReadStream('grafico-furia.png'));
      fs.unlink('grafico-furia.png', () => {});
      break;

    case 'üéØ √öltimos resultados':
      const res = await UltimosResultados();
      bot.sendMessage(chatId, res || 'Nenhum resultado dispon√≠vel!');
      break;

    case 'üîç Info do time':
      const info = await Info(1);
      bot.sendMessage(chatId, info);
      break;

    case 'üéÆ Estat√≠sticas dos Jogadores': 
      const players = await playersList();

      const playerButtons = players.map(player => {
          return {
              text: player.name,  
              callback_data: `player_${player.id}`  
          };
      });

    
      const keyboard = {
          reply_markup: {
              inline_keyboard: [playerButtons] 
          }
      };
    bot.sendMessage(chatId, 'Escolha um jogador para ver as estat√≠sticas:', keyboard);
    break;
    case 'üéÆ Pr√≥ximos jogos':
      await bot.sendMessage(chatId, '‚è≥ Buscando jogos...');
      const proximos = await ProximosJogos();
      bot.sendMessage(chatId, proximos);
    break;

    default:
      try {
        const { intencao, mensagem } = await interpretarMensagemUsuario(text);
    
        switch (intencao) {
          case 'ranking':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            await bot.sendMessage(chatId, '/ranking (em breve com bot√£o üòé)');
            break;
    
          case 'eventos_futuros':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            const evento = await getEventos();
            await bot.sendMessage(chatId, evento);
            break;
    
          case 'eventos_passados':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            const ultimos = await GetPastEvents();
            await bot.sendMessage(chatId, ultimos || 'Nenhum evento passado encontrado.');
            break;
    
          case 'ultimo_post':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            const post = await getUltimoPostTwitter();
            await bot.sendMessage(chatId, post);
            break;
    
          case 'grafico_rank':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            await gerarGrafico();
            await bot.sendPhoto(chatId, fs.createReadStream('grafico-furia.png'));
            fs.unlink('grafico-furia.png', () => {});
            break;
    
          case 'ultimos_resultados':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            const res = await UltimosResultados();
            await bot.sendMessage(chatId, res || 'Nenhum resultado dispon√≠vel.');
            break;
    
          case 'info_time':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            const info = await Info(1);
            await bot.sendMessage(chatId, info);
            break;
    
          case 'player_stats':
            await bot.sendMessage(chatId, '‚è≥ Pensando...');
            const players = await playersList();
            const playerButtons = players.map(player => [{
              text: player.name,
              callback_data: `player_${player.id}`
            }]);
            await bot.sendMessage(chatId, "Escolha um jogador para ver as estat√≠sticas:", {
              reply_markup: { inline_keyboard: playerButtons }
            });
            break;
    
          case 'proximos_jogos':
            await bot.sendMessage(chatId, 'üéÆ Buscando os pr√≥ximos jogos da FURIA...');
            const jogos = await ProximosJogos();
            await bot.sendMessage(chatId, jogos);
            break;
    
          case 'desconhecido':
          default:
            if (mensagem) {
              await bot.sendMessage(chatId, mensagem);
            } else {
              await bot.sendMessage(chatId, 'N√£o entendi muito bem, mas bora trocar uma ideia! üòé');
            }
            break;
        }
      } catch (err) {
        console.error("Erro ao usar a IA:", err);
        bot.sendMessage(chatId, '‚ùå Tive um problema para entender o que voc√™ disse. Tenta de novo?');
      }
      break;
    
}
});

const http = require('http');
const PORT = process.env.PORT || 3000;

http.createServer((req, res) => {
  res.writeHead(200, { 'Content-Type': 'text/plain' });
  res.end('Bot is running\n');
}).listen(PORT, () => {
  console.log(`Fake server listening on port ${PORT}`);
});

